#+PROPERTY: header-args :results value verbatim
#+TITLE: Notes on: Paradigms of artificial intelligence programming: case studies in Common Lisp by Norvig, P. (1992)
#+Time-stamp: <2021-06-15 20:44:59 boxx>



- source :: cite:norvig-1992-parad

* TODO Summary

* TODO Comments

* TODO Topics

** Introduction to Lisp

We will refer to anything that can be represented in the memory of a computer as a /computational object/, or just an /object/.

One advantage of parenthesized prefix notation is that the parentheses clearly mark the beginning and end of an expression. The Lisp notation may look unusual compared to standard mathematical notation, but there are advantages to this notation; since Lisp expressions can consist of a function followed by any number of arguments, we don't have to keep repeating the "+". More important than the notation is the rule for evaluation. In Lisp, lists are evaluated by first evaluating all the arguments, then applying the function to the arguments, thereby computing the result.

Sometimes programmers who are familiar with other languages have preconceptions that make it difficult for them to learn Lisp. For them, three (3) points are worth stressing here.

  1. First, many other languages make a distinction between statements and expressions. An expression, like ~2 + 2~, has a value, but a statement, like ~x = 2 + 2~ does not. Statements have effects, but they do *not* return values. *In Lisp, there is no such distinction*: every expression returns a value. It is true that some expressions have effects, but even those expressions also return values.

  2. Second, the lexical rules for Lisp are much simpler than the rules for other languages. In particular, there are fewer punctuation characters; only parentheses, quote marks (single, double, and backward), spaces, and the comma serve to separate symbols from each other. Thus, while the statement ~y=a*x+3~ is analyzed as seven separate tokens in other languages, in Lisp it would be treated as a single symbol *(!)*. To get a list of tokens, we would have to insert spaces: ~(y = a * x + 3)~.

  3. Third, while many languages use semicolons to delimit statements, Lisp has *no* such need of semicolons, since expressions are delimited by parentheses. Lisp chooses to use semicolons for another purpose - to mark the beginning of a comment, which lasts until the end of the line.


*** Symbolic Computation

All we've done so far is manipulate numbers in the same way a simple pocket calculator would. Lisp is more useful than a calculator for two main reasons.

  1. First, it allows us to manipulate objects other than numbers.

  2. Second, it allows us to define new objects that might be useful in subsequent computations.

Besides numbers, Lisp can represent characters (letters), strings of characters, and arbitrary symbols, where we are free to interpret these symbols as referring to things outside the world of mathematics. Lisp can also build nonatomic objects *(!)* by combining several objects into a list. This capability is fundamental and well supported in the language; in fact, the name Lisp is short for LISt Processing.

Here's an example of a computation on lists:

#+begin_src lisp
(append '(Pat Kim) '(Robin Sandy))
#+end_src

#+RESULTS:
: (PAT KIM ROBIN SANDY)

The quote mark serves to block the evaluation of the following expression and returns it literally. If we just had the expression ~(Pat Kim)~, it would be evaluated by considering ~Pat~ as a function and applying it to the value of the expression ~Kim~. This is not what we had in mind. The quote mark instructs Lisp to treat the list as a piece of data *(!)* rather than as a function call.

#+begin_src lisp
'(Pat Kim)
#+end_src

#+RESULTS:
: (PAT KIM)

In other computer languages (and in English), quotes usually come in pairs: one to mark the beginning and one to mark the end. In Lisp, a single quote is used to mark the beginning of an expression. Since we /always/ know how long a single expression is - either to the end of an atom or to the matching parenthesis of a list - we don't need an explicit punctuation mark to tell us where the expression ends. Quotes can be used on lists, on symbols, and in fact on anything else.

There are four (4) important points to make about symbols:

  1. First, it is important to remember that Lisp does not attach any external significance to the objects it manipulates. For example, we naturally think of ~(Robin Sandy)~ as a list of two first names, and ~(John Q Public)~ as a list of one person's first name, middle initial, and last name. *Lisp has no such preconceptions*. To lisp, both ~Robin~ and ~xyzzy~ are perfectly good symbols.


  2. Second, to do the computations above, we had to know that ~append~, ~length~, and ~+~ are defined functions in Common Lisp. Learning a language involves remembering vocabulary items (or knowing where to look them up) as well as learning the basic rules for forming expressions and determining what they mean. Common Lisp provides over 700 built-in functions.


  3. Third, note that symbols in Common Lisp are *not* case sensitive.


  4. Fourth, note that a wide variety of characters are allowed in symbols: numbers, letters, and other punctuation marks like '+' or '!'. The exact rules for what constitutes a symbol are a little complicated, but the normal convention is to use symbols consisting mostly of letters, with words separated by a dash, and perhaps with a number at the end.

*** Variables

We have seen some of the basics of symbolic computation. Now we move on to perhaps the most important *(!)* characteristic of a programming language: /the ability to define new objects in terms of other, and to name these objects for future use/. Here symbols again play an important role - they are used to name variables. A variable can take on a value, which can be /any/ Lisp object. One way to give a value to a variable is with ~setf~:

#+begin_src lisp
  (setf p '(John Q Public))
#+end_src

#+RESULTS:
: (JOHN Q PUBLIC)
(JOHN Q PUBLIC)
(JOHN Q PUBLIC)
(JOHN Q PUBLIC)
(JOHN Q PUBLIC)

#+begin_src lisp
  p
#+end_src

#+RESULTS:
(JOHN Q PUBLIC)
(JOHN Q PUBLIC)
(JOHN Q PUBLIC)

#+begin_src lisp
  (setf x 10)
#+end_src

#+RESULTS:
10
10

#+begin_src lisp
  (+ x x)
#+end_src

#+RESULTS:
20

#+begin_src lisp
  (+ x (length p))
#+end_src

#+RESULTS:
13

After assigning the value ~(John Q Public)~ to the variable named ~p~, we can refer to the value with the name ~p~. Similarly, after assigning a value to the variable named ~x~, we can refer to both ~x~ and ~p~.

Symbols are also used to name functions in Common Lisp. Every symbol can be used as the name of a variable or a function, or both, although it is rare (and potentially confusing) to have symbols name both.

*** Special Forms

The careful reader will note that ~setf~ violates the evaluation rule. We said earlier that functions like ~+~, ~-~ and ~append~ work by first evaluating all their arguments and then applying the function to the result. But *(!)* ~setf~ doesn't follow that rule, because ~setf~ is *not* a function at all. Rather, it is part of the basic syntax of Lisp. Besides the syntax of atoms and function calls, Lisp has a small number of syntactic expressions. They are known as /special forms/ *(!)*. They serve the same purpose as statement in other programming languages, and indeed have some of the same syntactic markers, such as ~if~ and ~loop~.

There are two (2) main differences between Lisp's syntax and other languages.

  1. First, Lisp's syntactic forms are /always/ lists in which the first element is one of a small number of privileged symbols. ~setf~ is one of these symbols, so ~(setf x 10)~ is a special form.


  2. Second, special forms are expressions that return a value. This is in contrast to statements in most languages, which have an effect but do *not* return a value.


In evaluating an expression like ~(setf x (+ 1 2))~, we set the variable names by the symbol ~x~ to the value of ~(+ 1 2)~, which is 3. If ~setf~ were a normal function, we would evaluate both the symbol ~x~ and the expression ~(+ 1 2)~ and do something with these two values, which is not what we want at all. ~setf~ is called a special form because it does something special: if it did not exist, it would be impossible to write a function that assigns a value to a variable. *The philosophy of Lisp is to provide a small number of special forms to do things that could not otherwise be done, and then expect the user to write everything else as functions*.

The term /special form/ is used confusingly to refer both to symbols like~setf~ and expressions that start with them *(!)*, like ~(setf x 3)~. In the book /Common LISPcraft/, Wilensky resolves the ambiguity by calling ~setf~ a /special function/ and reserving the term /special form/ for ~(setf x 3)~. This terminology implies that ~setf~ is just another function, but a special one in that its first argument is not evaluated. Such a view made sense in the days when Lisp was primarily an interpreted language. *The modern view is that* ~setf~ *should not be considered some kind of abnormal function but rather a marker of special syntax that will be handled specially by the compiler*. Thus, the special form ~(setf x (+ 2 1))~ should be considered the equivalent of ~x = 2 + 1~ in C *(!)*. When there is risk of confusion, we will call ~setf~ a /special form operator/ and ~(setf x 3)~ a /special form expression/.

It turns out that the quote mark is just an abbreviation for another special form *(!)*. The expression '/x/ is equivalent to ~(quote x)~, a special form expression that evaluates to /x/. The special form operators used in this chapter are:

  - ~defun~: define function


  - ~defparameter~: define special variable


  - ~setf~: set variable or field to new value


  - ~let~: bind local variable(s)


  - ~case~: choose one of several alternatives


  - ~if~: do one thing or another, depending on a test


  - ~function~ (#'): refer to a function


  - ~quote~ ('): introduce constant data

*** Lists

So far we have seen two (2) functions that operate on lists: ~append~ and ~length~. Since lists are important, let's look at some more list processing functions:

#+begin_src lisp
p
#+end_src

#+RESULTS:
(JOHN Q PUBLIC)

#+begin_src lisp
(first p)
#+end_src

#+RESULTS:
JOHN

#+begin_src lisp
(rest p)
#+end_src

#+RESULTS:
(Q PUBLIC)

#+begin_src lisp
(second p)
#+end_src

#+RESULTS:
Q

#+begin_src lisp
(third p)
#+end_src

#+RESULTS:
PUBLIC

#+begin_src lisp
(fourth p)
#+end_src

#+RESULTS:
NIL

#+begin_src lisp
(length p)
#+end_src

#+RESULTS:
3

The functions ~first~, ~second~, ~third~, and ~fourth~ are aptly named. The function ~rest~ stands for "the rest of the list after the first element." The symbol ~nil~ and the form ~()~ are completely synonymous; they are both representations of the empty list. ~nil~ is also used to denote the "false" value in Lisp. Thus, ~(fourth p)~ is ~nil~ because there is no fourth element of ~p~. Note that lists need not be composed only of atoms, but can contain sublists as elements:

#+begin_src lisp
(setf x '((1st element) 2 (element 3) ((4)) 5))
#+end_src

#+RESULTS:
((1ST ELEMENT) 2 (ELEMENT 3) ((4)) 5)

#+begin_src lisp
(length x)
#+end_src

#+RESULTS:
5

#+begin_src lisp
(first x)
#+end_src

#+RESULTS:
(1ST ELEMENT)

#+begin_src lisp
(fourth x)
#+end_src

#+RESULTS:
((4))

#+begin_src lisp
(first (fourth x))
#+end_src

#+RESULTS:
(4)

#+begin_src lisp
(first (first (fourth x)))
#+end_src

#+RESULTS:
4

So far we have seen how to access parts of lists. It is also possible to build up new lists, as these examples show:

#+begin_src lisp
(cons 'Mr p)
#+end_src

#+RESULTS:
(MR JOHN Q PUBLIC)

#+begin_src lisp
p
#+end_src

#+RESULTS:
(JOHN Q PUBLIC)

#+begin_src lisp
(cons (first p) (rest p))
#+end_src

#+RESULTS:
(JOHN Q PUBLIC)

#+begin_src lisp
(setf town (list 'Anytown 'USA))
#+end_src

#+RESULTS:
(ANYTOWN USA)

#+begin_src lisp
(first (fourth x))
#+end_src

#+RESULTS:
(4)

#+begin_src lisp
(list p 'of town 'may 'have 'already 'won!)
#+end_src

#+RESULTS:
((JOHN Q PUBLIC) OF (ANYTOWN USA) MAY HAVE ALREADY WON!)

#+begin_src lisp
p
#+end_src

#+RESULTS:
(JOHN Q PUBLIC)

The function ~cons~ stands for "construct." It takes as arguments an element and a list, and constructs a new list whose first is the element and whose rest is the original list. ~list~ takes any number of elements as arguments and returns a new list containing those elements in order. We've already seen ~append~, which is similar to ~list~; it takes as arguments any number of lists and appends them all together, forming one big list. *Thus, the arguments to* ~append~ *must be lists, while the arguments to* ~list~ *may be lists or atoms*.

/It is important to note that these functions create new lists; they don't modify old ones/.

Now let's move away from abstract functions on lists, and consider a simple problem: given a person's name in the form of a list, how might we extract the family name? For ~(JOHN Q PUBLIC)~ we could just use the function ~third~, but that wouldn't work for someone with no middle name. There is a function called ~last~ in Lisp; perhaps that would work. We can experiment:

#+begin_src lisp
(last p)
#+end_src

#+RESULTS:
(PUBLIC)

#+begin_src lisp
(first (last p))
#+end_src

#+RESULTS:
PUBLIC

It turns out that ~last~ perversely returns a list of the last element, rather than the last element itself. Thus we need to combine ~first~ and ~last~ to pick out the actual last element. We would like to be able to save the work we've done, and give it a proper description, like ~last-name~. We could use ~setf~ to save the last name of ~p~, but that wouldn't help determine any other last name. Instead we want to define a new function that computes the last name of /any/ name that is represented as a list. This next section does just that.

*** Defining New Functions

The special form ~defun~ stands for "define function." It is used here to define a new function called ~last-name~.

#+begin_src lisp
    (defun last-name (name)
      "Select the last name from a name represented as a list."
      (first (last name)))
#+end_src

#+RESULTS:
: LAST-NAME

In general, a function takes the following form (where the documentation string is optional, and all other parts are required):

#+begin_example
(defun function-name (parameter ... )
  "documentation string"
  function-body ... )
#+end_example

The function must be a symbol, the parameters are usually symbols (with some complications to be explained later), and the function body consists of one or more expressions that are evaluated when the function is called. The last expression is returned as the value of the function call.

Once we have defined ~last-name~, we can use it just like any other Lisp function:

#+begin_src lisp
(last-name p)
#+end_src

#+RESULTS:
: PUBLIC

#+begin_src lisp
    (defun first-name (name)
      "Select the first name from a name represented as a list."
      (first name))
#+end_src

#+RESULTS:
: FIRST-NAME

#+begin_src lisp
(first-name p)
#+end_src

#+RESULTS:
: JOHN

*** Using Functions

One good thing about defining a list of names, as we did above, is that it makes it easier to test our functions. Consider the following expression, which can be used to test the ~last-name~ function:

#+begin_src lisp
      (setf names '((John Q Public) (Malcolm X)
                    (Admiral Grace Murray Hopper) (Spot)
                    (Aristotle) (A A Milne) (Z Z Top)
                    (Sir Larry Olivier) (Miss Scarlet)))
#+end_src

#+RESULTS:
: ((JOHN Q PUBLIC) (MALCOLM X) (ADMIRAL GRACE MURRAY HOPPER) (SPOT) (ARISTOTLE)
:  (A A MILNE) (Z Z TOP) (SIR LARRY OLIVIER) (MISS SCARLET))

#+begin_src lisp
(mapcar #'last-name names)
#+end_src

#+RESULTS:
: (PUBLIC X HOPPER SPOT ARISTOTLE MILNE TOP OLIVIER SCARLET)

The funny #' notation maps from the name of a function to the function itself. This is analogous to 'x notation. The built-in function ~mapcar~ is passed two arguments, a function and a list. It returns a list built by calling the function on every element of the input list.

The name of the function ~mapcar~ comes from the fact that it "maps" the function across each of the arguments. The ~car~ part of the name refers to the Lisp function ~car~, an old name for ~first~. ~cdr~ is an old name for ~rest~. The names stand for "contents of the address register" and "contents of the decrement register," the instructions that were used in the first implementation of Lisp on the IBM 704.

In general, ~mapcar~ expects an /n/-ary function as its first argument, followed by /n/ lists *(!)*. It first applies the function to the argument list obtained by collecting the first element on each list. Then it applies the function to the second element of each list, and so on, until one of the lists is exhausted. It returns a list of all the function values it has computed.

Now that we understand ~mapcar~, let's use it to test the ~first-name~ function:

#+begin_src lisp
(mapcar #'first-name names)
#+end_src

#+RESULTS:
| JOHN | MALCOLM | GRACE | SPOT | ARISTOTLE | A | Z | LARRY | SCARLET |

We might be disappointed with these results. Suppose we wanted a version of ~first-name~ which ignored titles like Admiral and Miss, and got to the "real" first name. We could proceed as follows:

#+begin_src lisp
    (defparameter *titles*
      '(Mr Mrs Miss Ms Sir Madam Dr Admiral Major General)
      "A list of titles that can appear at the start of a name.")
#+end_src

#+RESULTS:
: *TITLES*

We've introduced another new special form, ~defparameter~, which defines a parameter - a variable that does not change over the course of a computation, but that might change when we think of new things to add. The ~defparameter~ form both gives a value to the variable and makes it possible to use the variable in subsequent function definitions. It is a widely used convention among Lisp programmers to mark special variables by spelling their names with asterisk on either end. This isjust a convention; in Lisp, the asterisk is just another character that has no particular meaning.

We next give a new definition for ~first-name~, which supersedes the previous definition (just as we can change the value of a variable, we can also change the value of a function in Lisp; it is not necessary to recompile everything when a change is made). This definition says that if the first word of the name is a member of the list of titles, then we want to ignore the word and return the ~first-name~ of the rest of the words in the name. Otherwise, we use the first word, just as before. Another built-in function, ~member~, tests to see if its first argument is an element of the list passed as the second argument.

The special form ~if~ has the form (if /test/ /then-part/ /else-part/). There are many special forms for performing conditional tests in Lisp; ~if~ is the most appropriate for this example. An ~if~ form is evaluated by first evaluating the /test/ expression. If it is true, the /then-part/ is evaluated and returned as the value of the ~if~ form; otherwise the /else-part/ is evaluated and returned. While some languages insist that the value of a conditional test must be either ~true~ or ~false~, Lisp is much more forgiving. The test may legally evaluate to /any/ value at all. Only the value ~nil~ *(!)* is considered false; all other values are considered true *(!)*. In the definition of ~first-name~ below, the function ~member~ will return a non-nil (hence true) value if the first element of the name is in the list of titles, and will return ~nil~ (hence false) if it is not. Although all non-nil values are considered true, by convention the constant ~t~ is usually used to represent truth.

#+begin_src lisp
        (defun first-name (name)
          "Select the first name from a name represented as a list."
          (if (member (first name) *titles*)
              (first-name (rest name))
              (first name)))
#+end_src

#+RESULTS:
: FIRST-NAME

When we map the new ~first-name~ over the list of names, the results are more encouraging. In addition, the function gets the "right" result for '(Madam Major General Paula Jones) by dropping off titles one at a time.

#+begin_src lisp
(mapcar #'first-name names)
#+end_src

#+RESULTS:
: (JOHN MALCOLM GRACE SPOT ARISTOTLE A Z LARRY SCARLET)

#+begin_src lisp
(first-name '(Madam Major General Paula Jones))
#+end_src

#+RESULTS:
: PAULA

*(!)* We can see how this works by /tracing/ the execution of ~first-name~, and seeing the values passed to and returned from the function. The special forms of ~trace~ and ~untrace~ are used for this purpose.

#+begin_src lisp
(trace first-name)
#+end_src

#+RESULTS:
: (FIRST-NAME)

#+begin_src lisp
(first-name '(John Q Public))
#+end_src

#+RESULTS:
: JOHN

When ~first-name~ is called, the definition is entered with the single argument, ~name~, taking on the value ~(John Q Public)~. The value returned is ~JOHN~. Trace prints two lines indicating entry and exit from the function, and then Lisp, as usual, prints the final result, ~JOHN~.

The function ~first-name~ is said to be /recursive/ because its definition includes a call to itself. Programmers who are new to the concept of recursion sometimes find it mysterious. But recursive functions are really no different from nonrecursive ones. Any function is required to return the correct value for the given input(s). Another way to look at this requirement is to break it into two parts:

  1. a function must return a value, and

  2. it must *not* return any incorrect values.


This two-part requirement is equivalent to the first one, but it makes it easier to think about and design function definitions.

*** Higher-Order Functions

Functions in Lisp can not only be "called", or applied to arguments, they can also be manipulated just like any other kind of object. A function that takes another function as an argument is called a /higher-order function/ *(!)*. ~mapcar~ is an example. To demonstrate the higher-order function style of programming, we will define a new function called ~mappend~. It takes two arguments, a function and a list. ~mappend~ maps the function over each element of the list and appends together all the results. The first definition follows immediately from the description and the fact that the function ~apply~ can be used to apply a function to a list of arguments.

#+begin_src lisp
    (defun mappend (fn the-list)
      "Apply fn to each element of list and append the results."
      (apply #'append (mapcar fn the-list)))
#+end_src

#+RESULTS:
: MAPPEND

Now we experiment a little to see how ~apply~ and ~mappend~ work. The first example applies the addition function to a list of four numbers.

#+begin_src lisp
(apply #'+ '(1 2 3 4))
#+end_src

#+RESULTS:
: 10

The next example applies ~append~ to a list of two argument, where each argument is a list. If the argument were not lists, it would be an error.

#+begin_src lisp
(apply #'append '((1 2 3) (a b c)))
#+end_src

#+RESULTS:
: (1 2 3 A B C)

Now we define a new function, ~self-and-double~, and apply it to a variety of arguments.

#+begin_src lisp
(defun self-and-double (x) (list x (+ x x)))
#+end_src

#+RESULTS:
: SELF-AND-DOUBLE

#+begin_src lisp
(self-and-double 3)
#+end_src

#+RESULTS:
: (3 6)

#+begin_src lisp
(apply #'self-and-double '(3))
#+end_src

#+RESULTS:
: (3 6)

If we had tried to apply ~self-and-double~ to a list of more than one argument, or to a list that did not contain a number, it would be an error, just as it would be an error to evaluate ~(self-and-double 3 4)~. Now let's return to the mapping functions:

#+begin_src lisp
(mapcar #'self-and-double '(1 10 300))
#+end_src

#+RESULTS:
: ((1 2) (10 20) (300 600))

#+begin_src lisp
(mappend #'self-and-double '(1 10 300))
#+end_src

#+RESULTS:
: (1 2 10 20 300 600)

When ~mapcar~ is passed a function and a list of three arguments, it /always/ returns a list of three values. Each value is the result of calling the function on the respective argument. In contrast *(!)*, when ~mappend~ is called, it returns one big list *(!)*, which is equal to all the values that ~mapcar~ would generate appended together. It would be an error to call ~mappend~ with a function that didn't return lists, because ~append~ expects to see lists as its arguments.

Now consider the following problem: given a list of elements, return a list consisting of all the numbers in the original list and the negation of those numbers. For example, given the list ~(testing 1 2 3 test)~, return ~(1 -1 2 -2 3 -3)~. This problem can be solved bery easily using ~mappend~ as a component:

#+begin_src lisp
  (defun numbers-and-negations (input)
  "Given a list, return only the numbers and their negations."
  (mappend #'number-and-negation input))
#+end_src

#+RESULTS:
: NUMBERS-AND-NEGATIONS

#+begin_src lisp
  (defun number-and-negation (x)
  "If x is a number, return a list of x and -x."
  (if (numberp x)
    (list x (- x))
    nil))
#+end_src

#+RESULTS:
: NUMBER-AND-NEGATION

#+begin_src lisp
(numbers-and-negations '(testing 1 2 3 test))
#+end_src

#+RESULTS:
: (1 -1 2 -2 3 -3)

The alternate definition of ~mappend~ shown in the following doesn't make use of ~mapcar~, instead it builds up the list one element at a time:

#+begin_src lisp
  (defun mappend (fn the-list)
  "Apply fn to each element of list and append the results."
  (if (null the-list)
    nil
  (append (funcall fn (first the-list))
        (mappend fn (rest the-list)))))
#+end_src

#+RESULTS:
: MAPPEND

~funcall~ is similar to ~apply~; it too takes a function as its first argument and applies the function to a list of arguments, but *(!)* in the case of ~funcall~, the arguments are listed separately.

#+begin_src lisp
(funcall #'+ 2 3)
#+end_src

#+RESULTS:
: 5

#+begin_src lisp
(apply #'+ '(2 3))
#+end_src

#+RESULTS:
: 5

These are equivalent to ~(+ 2 3)~.

So far, every function we have used has been either predefined in Common Lisp or introduced with a ~defun~, which pairs a function with a name. It is also possible to introduce a function without giving it a name, using the special syntax ~lambda~.

The name /lambda/ comes from the mathematician Alonzo Church's notation for functions. Lisp usually prefers expressive names over terse Greek letters, but *(!)* lambda is an exception. A better name would be ~make-function~. Lambda derives from the notation in Russell and Whitehead's /Principia Mathematica/, which used a caret over bound variables: \widehat{x} (x + x). Church wanted a one-dimensional string, so he moved the caret in front: ^x(x + x). The caret looked funny with nothing below it, so Church switched to the closest thing, an uppercse lambda: \Lambda\x(x + x). The \Lambda was easily confused with other symbols, so eventually the lowercase lambda was substituted \lambda\x(x + x). John McCarthy was a student of Church's at Princeton, so when McCarthy invented Lisp in 1958, he adopted the lambda notation. There were no Greek letters on the keypunches of that era, so McCarthy used ~(lambda (x) (+ x x))~, and it has survived to this day. In general, the form of a lambda expression is

(lambda (/parameters/ ...) /body/ ...)

A lambda expression is just a nonatomic /name/ *(!)* for a function, just as ~append~ is an atomic name for a built-in function. As such, it is appropriate for use in the first position of a function call, but if we want to get at the actual function, rather than its name, we *still* have to use the #' notation. For example:

#+begin_src lisp
((lambda (x) (+ x 2)) 4)
#+end_src

#+RESULTS:
: 6

#+begin_src lisp
(funcall #'(lambda (x) (+ x 2)) 4)
#+end_src

#+RESULTS:
: 6

To understand the distinction we have to be clear on how expressions are evaluated in Lisp. The normal rule for evaluation states that symbols are evaluated by looking up the value of the variable that the symbol refers to. So the ~x~ in ~(+ x 2)~ is evaluated by looking up the value of the variable named ~x~. A list is evaluated in one of two (2) ways.

  1. If the first element of the list is a special form operator, then the list is evaluated according to the syntax rule for that special form.

  2. Otherwise, the list represents a function call *(!)*. The first element is evaluated in a uniqie way, as a function. This means that it can *either* be a symbol *or* a lambda expression. In either case, the function named by the first element is applied to the values of the remaining elements in the list. These values are determined by the normal evaluation rules. If we want to refer to a function in a position rather than the first element of a function call, we have to use the #' notation. Otherwise, the expressions will be evaluated by the normal evaluation rule, and will not be treated as functions.

 #+begin_src lisp
(mapcar #'(lambda (x) (+ x x)) '(1 2 3 4 5))
 #+end_src

 #+RESULTS:
 : (2 4 6 8 10)

 #+begin_src lisp
(mappend #'(lambda (l) (list l (reverse l))) '((1 2 3) (a b c)))
 #+end_src

 #+RESULTS:
 : ((1 2 3) (3 2 1) (A B C) (C B A))

 Programmers who are used to other languages sometimes fail to see the point of lambda expressions. There are two (2) reasons why lambda expressions are very useful.

   1. First, it can be messy to clutter up a program with superfluous names. Just as it is clearer to write ~(a+b)*(c+d)~ rather than to invent variable names like ~temp1~ and ~temp2~ to hold ~a+b~ and ~c+d~, so it can be clearer to define a function as a lambda expression rather than inventing a name for it.

   2. Second, and more importantly *(!)*, lambda expressions make it possible to create new functions at run time *(!)*. This is a powerful *(!)* technique that is not possible in most programming languages. These run-time functions, known as *closures*, will be discussed in section 3.16.

*** Other Data Types

So far we have seen just four (4) kinds of Lisp objects:

  - numbers,
  - symbols,
  - lists, and
  - functions.

Lisp actually defines about 25 different types of objects: vectors, arrays, structures, characters, streams, hash tables, and others. At this point we will introduce one more, the string. As you can see in the following, strings, like numbers, evaluate to themselves *(!)*. Strings are used mainly for printing out messages, while symbols are used for their relationships to other objects, and to name variables. The printed representation of a string has a double quote mark (") at each end.

#+begin_src lisp
"a string"
#+end_src

#+RESULTS:
: a string

#+begin_src lisp
(length "a string")
#+end_src

#+RESULTS:
: 8

#+begin_src lisp
(length "")
#+end_src

#+RESULTS:
: 0

*** Summary: The Lisp Evaluation Rule

We can now summarize the evaluation rule for Lisp.
