#+PROPERTY: header-args :exports both
#+TITLE: Notes on: Paradigms of artificial intelligence programming: case studies in Common Lisp by Norvig, P. (1992)
#+Time-stamp: <2021-06-11 15:27:11 boxx>



- source :: cite:norvig-1992-parad

* TODO Summary

* TODO Comments

* TODO Topics

** Introduction to Lisp

We will refer to anything that can be represented in the memory of a computer as a /computational object/, or just an /object/.

One advantage of parenthesized prefix notation is that the parentheses clearly mark the beginning and end of an expression. The Lisp notation may look unusual compared to standard mathematical notation, but there are advantages to this notation; since Lisp expressions can consist of a function followed by any number of arguments, we don't have to keep repeating the "+". More important than the notation is the rule for evaluation. In Lisp, lists are evaluated by first evaluating all the arguments, then applying the function to the arguments, thereby computing the result.

Sometimes programmers who are familiar with other languages have preconceptions that make it difficult for them to learn Lisp. For them, three (3) points are worth stressing here.

  1. First, many other languages make a distinction between statements and expressions. An expression, like ~2 + 2~, has a value, but a statement, like ~x = 2 + 2~ does not. Statements have effects, but they do *not* return values. *In Lisp, there is no such distinction*: every expression returns a value. It is true that some expressions have effects, but even those expressions also return values.

  2. Second, the lexical rules for Lisp are much simpler than the rules for other languages. In particular, there are fewer punctuation characters; only parentheses, quote marks (single, double, and backward), spaces, and the comma serve to separate symbols from each other. Thus, while the statement ~y=a*x+3~ is analyzed as seven separate tokens in other languages, in Lisp it would be treated as a single symbol *(!)*. To get a list of tokens, we would have to insert spaces: ~(y = a * x + 3)~.

  3. Third, while many languages use semicolons to delimit statements, Lisp has *no* such need of semicolons, since expressions are delimited by parentheses. Lisp chooses to use semicolons for another purpose - to mark the beginning of a comment, which lasts until the end of the line.


*** Symbolic Computation

All we've done so far is manipulate numbers in the same way a simple pocket calculator would. Lisp is more useful than a calculator for two main reasons.

  1. First, it allows us to manipulate objects other than numbers.

  2. Second, it allows us to define new objects that might be useful in subsequent computations.

Besides numbers, Lisp can represent characters (letters), strings of characters, and arbitrary symbols, where we are free to interpret these symbols as referring to things outside the world of mathematics. Lisp can also build nonatomic objects *(!)* by combining several objects into a list. This capability is fundamental and well supported in the language; in fact, the name Lisp is short for LISt Processing.

Here's an example of a computation on lists:

#+begin_src lisp
(append '(Pat Kim) '(Robin Sandy))
#+end_src

#+RESULTS:
| PAT | KIM | ROBIN | SANDY |

The quote mark serves to block the evaluation of the following expression and returns it literally. If we just had the expression ~(Pat Kim)~, it would be evaluated by considering ~Pat~ as a function and applying it to the value of the expression ~Kim~. This is not what we had in mind. The quote mark instructs Lisp to treat the list as a piece of data *(!)* rather than as a function call.

#+begin_src lisp
'(Pat Kim)
#+end_src

#+RESULTS:
| PAT | KIM |

In other computer languages (and in English), quotes usually come in pairs: one to mark the beginning and one to mark the end. In Lisp, a single quote is used to mark the beginning of an expression. Since we /always/ know how long a single expression is - either to the end of an atom or to the matching parenthesis of a list - we don't need an explicit punctuation mark to tell us where the expression ends. Quotes can be used on lists, on symbols, and in fact on anything else.

There are four (4) important points to make about symbols:

  1. First, it is important to remember that Lisp does not attach any external significance to the objects it manipulates. For example, we naturally think of ~(Robin Sandy)~ as a list of two first names, and ~(John Q Public)~ as a list of one person's first name, middle initial, and last name. *Lisp has no such preconceptions*. To lisp, both ~Robin~ and ~xyzzy~ are perfectly good symbols.


  2. Second, to do the computations above, we had to know that ~append~, ~length~, and ~+~ are defined functions in Common Lisp. Learning a language involves remembering vocabulary items (or knowing where to look them up) as well as learning the basic rules for forming expressions and determining what they mean. Common Lisp provides over 700 built-in functions.


  3. Third, note that symbols in Common Lisp are *not* case sensitive.


  4. Fourth, note that a wide variety of characters are allowed in symbols: numbers, letters, and other punctuation marks like '+' or '!'. The exact rules for what constitutes a symbol are a little complicated, but the normal convention is to use symbols consisting mostly of letters, with words separated by a dash, and perhaps with a number at the end.

*** Variables

We have seen some of the basics of symbolic computation. Now we move on to perhaps the most important *(!)* characteristic of a programming language: /the ability to define new objects in terms of other, and to name these objects for future use/. Here symbols again play an important role - they are used to name variables. A variable can take on a value, which can be /any/ Lisp object. One way to give a value to a variable is with ~setf~:

#+begin_src lisp
  (setf p '(John Q Public))
#+end_src

#+RESULTS:
(JOHN Q PUBLIC)
(JOHN Q PUBLIC)
(JOHN Q PUBLIC)
(JOHN Q PUBLIC)

#+begin_src lisp
  p
#+end_src

#+RESULTS:
(JOHN Q PUBLIC)
(JOHN Q PUBLIC)
(JOHN Q PUBLIC)

#+begin_src lisp
  (setf x 10)
#+end_src

#+RESULTS:
10
10

#+begin_src lisp
  (+ x x)
#+end_src

#+RESULTS:
20

#+begin_src lisp
  (+ x (length p))
#+end_src

#+RESULTS:
13

After assigning the value ~(John Q Public)~ to the variable named ~p~, we can refer to the value with the name ~p~. Similarly, after assigning a value to the variable named ~x~, we can refer to both ~x~ and ~p~.

Symbols are also used to name functions in Common Lisp. Every symbol can be used as the name of a variable or a function, or both, although it is rare (and potentially confusing) to have symbols name both.

*** Special Forms

The careful reader will note that ~setf~ violates the evaluation rule. We said earlier that functions like ~+~, ~-~ and ~append~ work by first evaluating all their arguments and then applying the function to the result. But *(!)* ~setf~ doesn't follow that rule, because ~setf~ is *not* a function at all. Rather, it is part of the basic syntax of Lisp. Besides the syntax of atoms and function calls, Lisp has a small number of syntactic expressions. They are known as /special forms/ *(!)*. They serve the same purpose as statement in other programming languages, and indeed have some of the same syntactic markers, such as ~if~ and ~loop~.

There are two (2) main differences between Lisp's syntax and other languages.

  1. First, Lisp's syntactic forms are /always/ lists in which the first element is one of a small number of privileged symbols. ~setf~ is one of these symbols, so ~(setf x 10)~ is a special form.


  2. Second, special forms are expressions that return a value. This is in contrast to statements in most languages, which have an effect but do *not* return a value.


In evaluating an expression like ~(setf x (+ 1 2))~, we set the variable names by the symbol ~x~ to the value of ~(+ 1 2)~, which is 3. If ~setf~ were a normal function, we would evaluate both the symbol ~x~ and the expression ~(+ 1 2)~ and do something with these two values, which is not what we want at all. ~setf~ is called a special form because it does something special: if it did not exist, it would be impossible to write a function that assigns a value to a variable. *The philosophy of Lisp is to provide a small number of special forms to do things that could not otherwise be done, and then expect the user to write everything else as functions*.

The term /special form/ is used confusingly to refer both to symbols like~setf~ and expressions that start with them *(!)*, like ~(setf x 3)~. In the book /Common LISPcraft/, Wilensky resolves the ambiguity by calling ~setf~ a /special function/ and reserving the term /special form/ for ~(setf x 3)~. This terminology implies that ~setf~ is just another function, but a special one in that its first argument is not evaluated. Such a view made sense in the days when Lisp was primarily an interpreted language. *The modern view is that* ~setf~ *should not be considered some kind of abnormal function but rather a marker of special syntax that will be handled specially by the compiler*. Thus, the special form ~(setf x (+ 2 1))~ should be considered the equivalent of ~x = 2 + 1~ in C *(!)*. When there is risk of confusion, we will call ~setf~ a /special form operator/ and ~(setf x 3)~ a /special form expression/.

It turns out that the quote mark is just an abbreviation for another special form *(!)*. The expression '/x/ is equivalent to ~(quote x)~, a special form expression that evaluates to /x/. The special form operators used in this chapter are:

  - ~defun~: define function


  - ~defparameter~: define special variable


  - ~setf~: set variable or field to new value


  - ~let~: bind local variable(s)


  - ~case~: choose one of several alternatives


  - ~if~: do one thing or another, depending on a test


  - ~function~ (#'): refer to a function


  - ~quote~ ('): introduce constant data

*** Lists

So far we have seen two (2) functions that operate on lists: ~append~ and ~length~. Since lists are important, let's look at some more list processing functions:

#+begin_src lisp
p
#+end_src

#+RESULTS:
(JOHN Q PUBLIC)

#+begin_src lisp
(first p)
#+end_src

#+RESULTS:
JOHN

#+begin_src lisp
(rest p)
#+end_src

#+RESULTS:
(Q PUBLIC)

#+begin_src lisp
(second p)
#+end_src

#+RESULTS:
Q

#+begin_src lisp
(third p)
#+end_src

#+RESULTS:
PUBLIC

#+begin_src lisp
(fourth p)
#+end_src

#+RESULTS:
NIL

#+begin_src lisp
(length p)
#+end_src

#+RESULTS:
3

The functions ~first~, ~second~, ~third~, and ~fourth~ are aptly named. The function ~rest~ stands for "the rest of the list after the first element." The symbol ~nil~ and the form ~()~ are completely synonymous; they are both representations of the empty list. ~nil~ is also used to denote the "false" value in Lisp. Thus, ~(fourth p)~ is ~nil~ because there is no fourth element of ~p~. Note that lists need not be composed only of atoms, but can contain sublists as elements:

#+begin_src lisp
(setf x '((1st element) 2 (element 3) ((4)) 5))
#+end_src

#+RESULTS:
((1ST ELEMENT) 2 (ELEMENT 3) ((4)) 5)

#+begin_src lisp
(length x)
#+end_src

#+RESULTS:
5

#+begin_src lisp
(first x)
#+end_src

#+RESULTS:
(1ST ELEMENT)

#+begin_src lisp
(fourth x)
#+end_src

#+RESULTS:
((4))

#+begin_src lisp
(first (fourth x))
#+end_src

#+RESULTS:
(4)

#+begin_src lisp
(first (first (fourth x)))
#+end_src

#+RESULTS:
4

So far we have seen how to access parts of lists. It is also possible to build up new lists, as these examples show:

#+begin_src lisp
(cons 'Mr p)
#+end_src

#+RESULTS:
(MR JOHN Q PUBLIC)

#+begin_src lisp
p
#+end_src

#+RESULTS:
(JOHN Q PUBLIC)

#+begin_src lisp
(cons (first p) (rest p))
#+end_src

#+RESULTS:
(JOHN Q PUBLIC)

#+begin_src lisp
(setf town (list 'Anytown 'USA))
#+end_src

#+RESULTS:
(ANYTOWN USA)

#+begin_src lisp
(first (fourth x))
#+end_src

#+RESULTS:
(4)

#+begin_src lisp
(list p 'of town 'may 'have 'already 'won!)
#+end_src

#+RESULTS:
((JOHN Q PUBLIC) OF (ANYTOWN USA) MAY HAVE ALREADY WON!)

#+begin_src lisp
p
#+end_src

#+RESULTS:
(JOHN Q PUBLIC)

The function ~cons~ stands for "construct." It takes as arguments an element and a list, and constructs a new list whose first is the element and whose rest is the original list. ~list~ takes any number of elements as arguments and returns a new list containing those elements in order. We've already seen ~append~, which is similar to ~list~; it takes as arguments any number of lists and appends them all together, forming one big list. *Thus, the arguments to* ~append~ *must be lists, while the arguments to* ~list~ *may be lists or atoms*.

/It is important to note that these functions create new lists; they don't modify old ones/.

Now let's move away from abstract functions on lists, and consider a simple problem: given a person's name in the form of a list, how might we extract the family name? For ~(JOHN Q PUBLIC)~ we could just use the function ~third~, but that wouldn't work for someone with no middle name. There is a function called ~last~ in Lisp; perhaps that would work. We can experiment:

#+begin_src lisp
(last p)
#+end_src

#+RESULTS:
(PUBLIC)

#+begin_src lisp
(first (last p))
#+end_src

#+RESULTS:
PUBLIC

It turns out that ~last~ perversely returns a list of the last element, rather than the last element itself. Thus we need to combine ~first~ and ~last~ to pick out the actual last element. We would like to be able to save the work we've done, and give it a proper description, like ~last-name~. We could use ~setf~ to save the last name of ~p~, but that wouldn't help determine any other last name. Instead we want to define a new function that computes the last name of /any/ name that is represented as a list. This next section does just that.

*** Defining New Functions
